#!/usr/bin/env node
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/plugins/github/bin/generateGraphqlFlowTypes.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/graphql/generateFlowTypes.js":
/*!******************************************!*\
  !*** ./src/graphql/generateFlowTypes.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return generateFlowTypes; });\n/* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prettier */ \"prettier\");\n/* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prettier__WEBPACK_IMPORTED_MODULE_0__);\nfunction generateFlowTypes(schema,prettierOptions){const definitions=[];function formatField(field){switch(field.type){case\"ID\":return formatIdField(field);case\"PRIMITIVE\":return formatPrimitiveField(field);case\"NODE\":return formatNodeField(field);case\"CONNECTION\":return formatConnectionField(field);case\"NESTED\":return formatNestedField(field);// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(field.type);}}function formatIdField(_unused_field){return\"string\";}function formatFidelity(nominal,fidelity){switch(fidelity.type){case\"FAITHFUL\":return nominal;case\"UNFAITHFUL\":{const values=Object.keys(fidelity.actualTypenames).sort();return values.length===0?\"empty\":values.join(\" | \");}// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(fidelity.type);}}function formatPrimitiveField(field){if(field.annotation==null){return\"mixed\";}else if(field.annotation.nonNull){return field.annotation.elementType;}else{return\"null | \"+field.annotation.elementType;}}function formatNodeField(field){const elementType=formatFidelity(field.elementType,field.fidelity);return\"null | \".concat(elementType);}function formatConnectionField(field){const elementType=formatFidelity(field.elementType,field.fidelity);return\"$ReadOnlyArray<null | \".concat(elementType,\">\");}function formatNestedField(field){const eggs=[];for(const eggName of Object.keys(field.eggs).sort()){eggs.push({eggName,rhs:formatField(field.eggs[eggName])});}const eggContents=eggs.map(x=>\"+\".concat(x.eggName,\": \").concat(x.rhs)).join(\", \");return\"null | {|\\n\".concat(eggContents,\"\\n|}\");}for(const typename of Object.keys(schema).sort()){const type=schema[typename];switch(type.type){case\"SCALAR\":definitions.push(\"export type \".concat(typename,\" = \").concat(type.representation,\";\"));break;case\"ENUM\":{const values=Object.keys(type.values).sort().map(x=>JSON.stringify(x));// export type E = \"A\" | \"B\";\nconst typeRhs=values.length===0?\"empty\":values.join(\" | \");definitions.push(\"export type \".concat(typename,\" = \").concat(typeRhs,\";\"));// export const E$Values: {|+A: \"A\", +B: \"B\"|} = deepFreeze(...);\nconst objectName=\"\".concat(typename,\"$Values\");const objectType=[\"{|\",values.map(x=>\"+\".concat(x,\": \").concat(x)).join(\", \"),\"|}\"].join(\"\");const objectValue=[\"deepFreeze({\",values.map(x=>\"\".concat(x,\": \").concat(x)).join(\", \"),\"})\"].join(\"\");definitions.push(\"export const \".concat(objectName,\": \").concat(objectType,\" = \").concat(objectValue,\";\"));break;}case\"OBJECT\":{const fields=[{fieldname:\"__typename\",rhs:JSON.stringify(typename)}];for(const fieldname of Object.keys(type.fields).sort()){fields.push({fieldname,rhs:formatField(type.fields[fieldname])});}const fieldContents=fields.map(x=>\"+\".concat(x.fieldname,\": \").concat(x.rhs)).join(\", \");const rhs=\"{|\\n\".concat(fieldContents,\"\\n|}\");definitions.push(\"export type \".concat(typename,\" = \").concat(rhs,\";\"));break;}case\"UNION\":{const rhs=Object.keys(type.clauses).length===0?\"empty\":Object.keys(type.clauses).sort().join(\" | \");definitions.push(\"export type \".concat(typename,\" = \").concat(rhs,\";\"));break;}// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(type.type);}}const rawSource=[\"// @flow\",\"// Autogenerated file. Do not edit.\",'import deepFreeze from \"deep-freeze\"',...definitions].join(\"\\n\\n\");return prettier__WEBPACK_IMPORTED_MODULE_0___default.a.format(rawSource,prettierOptions);}\n\n//# sourceURL=webpack:///./src/graphql/generateFlowTypes.js?");

/***/ }),

/***/ "./src/graphql/schema.js":
/*!*******************************!*\
  !*** ./src/graphql/schema.js ***!
  \*******************************/
/*! exports provided: faithful, unfaithful, schema, scalar, enum, object, union, id, primitive, node, connection, nonNull, nullable, nested */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"faithful\", function() { return faithful; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unfaithful\", function() { return unfaithful; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"schema\", function() { return schema; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scalar\", function() { return scalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enum\", function() { return enum_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"object\", function() { return object; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"union\", function() { return union; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"id\", function() { return id; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"primitive\", function() { return primitive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"node\", function() { return node; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connection\", function() { return connection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nonNull\", function() { return nonNull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nullable\", function() { return nullable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nested\", function() { return nested; });\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**\n * Data types to describe a particular subset of GraphQL schemata.\n * Schemata represented by this module must satisfy these constraints:\n *\n *   - Every object must have an `id` field of primitive type.\n *   - Every field of an object must be either a primitive, a reference\n *     to a single (possibly nullable) object, or a _connection_ as\n *     described in the Relay cursor connections specification. In\n *     particular, no field may directly contain a list.\n *   - Interface types must be represented as unions of all their\n *     implementations.\n */ // The name of a GraphQL type, like `Repository` or `Int`.\n// The name of a GraphQL object field, like `name` or `pullRequests`.\n// The database-wide unique ID of a GraphQL object.\n// Description of a GraphQL schema. Types are represented as follows:\n//   - An object type is represented directly as an `OBJECT`.\n//   - A union type is represented directly as a `UNION`.\n//   - An interface type is represented as a `UNION` of all its\n//     implementations.\n//   - Scalars and enums may only occur as object fields, and are\n//     represented as `PRIMITIVE`s (except for `ID`s).\n//   - Connections are supported as object fields, but arbitrary lists\n//     are not.\n//\n// Primitive and enum fields on an object type may optionally be\n// annotated with their representations.\n//\n// To accommodate schemata where some object types do not have IDs,\n// objects may have \"nested\" fields of primitive or node-reference type.\n// These may be nested to depth exactly 1. Suppose that `Foo` is an\n// object type that includes `bar: Bar!`, but `Bar` is an object type\n// without an `id`. Then `Bar` may not be a first-class type, but `Foo`\n// may pull properties off of it using\n//\n//     bar: nested({x: primitive(), y: node(\"Baz\")});\n//\n// The property \"bar\" in the above example is called a _nested_\n// property, and its fields \"x\" and \"y\" are called _eggs_. (The nest\n// contains the eggs.)\n// A field is _faithful_ if selecting its `__typename` and `id` will\n// always yield the correct `__typename` for the node of the given ID.\n// In theory, this should always be the case, but some remote schemas\n// are broken. For details, see:\n//\n//   - https://github.com/sourcecred/sourcecred/issues/996\n//   - https://github.com/sourcecred/sourcecred/issues/998\n//\n// For an unfaithful field, the `actualTypenames` property lists all the\n// types of objects that can _actually_ be returned when the field is\n// queried. (This set only affects generated Flow types, not runtime\n// semantics.) These must all be object types.\n//\n// It is always sound to represent an actually-faithful field as\n// unfaithful, but doing so may incur additional queries. Marking a type\n// as faithful should be seen as an optimization that may be performed\n// only when the server is abiding by its contract for that field.\nfunction faithful(){return{type:\"FAITHFUL\"};}function unfaithful(actualTypenames){const actualTypenamesObject={};for(const t of actualTypenames){actualTypenamesObject[t]=true;}return{type:\"UNFAITHFUL\",actualTypenames:actualTypenamesObject};}// Every object must have exactly one `id` field, and it must have this\n// name.\nconst ID_FIELD_NAME=\"id\";function schema(types){function assertKind(path,elementTypename,validKinds){let{isFidelity=false}=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};const self=(isFidelity?\"unfaithful typenames list of \":\"\")+\"field \".concat(path.map(x=>JSON.stringify(x)).join(\"/\"));const elementType=types[elementTypename];if(elementType==null){throw new Error(\"\".concat(self,\" has unknown type: \\\"\").concat(elementTypename,\"\\\"\"));}if(!validKinds.includes(elementType.type)){throw new Error(\"\".concat(self,\" has invalid type \\\"\").concat(elementTypename,\"\\\" \")+\"of kind \\\"\".concat(elementType.type,\"\\\"\"));}}function validateFidelity(path,fidelity){switch(fidelity.type){case\"FAITHFUL\":break;case\"UNFAITHFUL\":for(const typename of Object.keys(fidelity.actualTypenames)){assertKind(path,typename,[\"OBJECT\"],{isFidelity:true});}break;// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(fidelity.type);}}const result={};for(const typename of Object.keys(types)){const type=types[typename];switch(type.type){case\"SCALAR\":result[typename]={type:\"SCALAR\",representation:type.representation};break;case\"ENUM\":result[typename]={type:\"ENUM\",values:_objectSpread({},type.values)};break;case\"OBJECT\":for(const fieldname of Object.keys(type.fields)){const field=type.fields[fieldname];switch(field.type){case\"ID\":// Nothing to check.\nbreak;case\"PRIMITIVE\":if(field.annotation!=null){assertKind([typename,fieldname],field.annotation.elementType,[\"SCALAR\",\"ENUM\"]);}break;case\"NODE\":assertKind([typename,fieldname],field.elementType,[\"OBJECT\",\"UNION\"]);validateFidelity([typename,fieldname],field.fidelity);break;case\"CONNECTION\":assertKind([typename,fieldname],field.elementType,[\"OBJECT\",\"UNION\"]);validateFidelity([typename,fieldname],field.fidelity);break;case\"NESTED\":for(const eggName of Object.keys(field.eggs)){const egg=field.eggs[eggName];switch(egg.type){case\"PRIMITIVE\":if(egg.annotation!=null){assertKind([typename,fieldname,eggName],egg.annotation.elementType,[\"SCALAR\",\"ENUM\"]);}break;case\"NODE\":assertKind([typename,fieldname,eggName],egg.elementType,[\"OBJECT\",\"UNION\"]);validateFidelity([typename,fieldname,eggName],egg.fidelity);break;// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(egg.type);}}break;// istanbul ignore next: unreachable per Flow\ndefault:throw new Error(field.type);}}result[typename]={type:\"OBJECT\",fields:_objectSpread({},type.fields)};break;case\"UNION\":for(const clause of Object.keys(type.clauses)){const clauseType=types[clause];if(clauseType==null){throw new Error(\"union has unknown clause: \\\"\".concat(typename,\"\\\"/\\\"\").concat(clause,\"\\\"\"));}if(clauseType.type!==\"OBJECT\"){// The GraphQL spec doesn't permit unions of interfaces or\n// other unions (or primitives). This is nice, because it\n// means that we don't have to worry about ill-founded\n// unions.\nthrow new Error(\"union has non-object type clause: \\\"\".concat(typename,\"\\\"/\\\"\").concat(clause,\"\\\"\"));}}result[typename]={type:\"UNION\",clauses:_objectSpread({},type.clauses)};break;// istanbul ignore next\ndefault:throw new Error(type.type);}}return result;}function scalar(representation){return{type:\"SCALAR\",representation};}function enum_(values){const valuesObject={};for(const v of values){valuesObject[v]=true;}return{type:\"ENUM\",values:valuesObject};}function object(fields){for(const fieldname of Object.keys(fields)){const field=fields[fieldname];if(fieldname===\"__typename\"){throw new Error(\"reserved field name: \"+fieldname);}if(field.type===\"ID\"&&fieldname!==ID_FIELD_NAME){throw new Error(\"invalid ID field with name \\\"\".concat(fieldname,\"\\\"\"));}}if(fields[ID_FIELD_NAME]==null){throw new Error(\"expected ID field with name \\\"\".concat(ID_FIELD_NAME,\"\\\"\"));}if(fields[ID_FIELD_NAME].type!==\"ID\"){throw new Error(\"field \\\"\".concat(ID_FIELD_NAME,\"\\\" must be an ID field\"));}// Workaround for <https://github.com/facebook/flow/issues/7128>.\nconst exactFields=_objectSpread({},fields);return{type:\"OBJECT\",fields:exactFields};}function union(clauses){const clausesMap={};for(const clause of clauses){if(clausesMap[clause]!=null){throw new Error(\"duplicate union clause: \\\"\".concat(clause,\"\\\"\"));}clausesMap[clause]=true;}return{type:\"UNION\",clauses:clausesMap};}function id(){return{type:\"ID\"};}function primitive(annotation){return{type:\"PRIMITIVE\",annotation:annotation||null};}function node(elementType){let fidelity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:faithful();return{type:\"NODE\",elementType,fidelity};}function connection(elementType){let fidelity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:faithful();return{type:\"CONNECTION\",elementType,fidelity};}function nonNull(elementType){return{nonNull:true,elementType};}function nullable(elementType){return{nonNull:false,elementType};}function nested(eggs){return{type:\"NESTED\",eggs:_objectSpread({},eggs)};}\n\n//# sourceURL=webpack:///./src/graphql/schema.js?");

/***/ }),

/***/ "./src/plugins/github/bin/generateGraphqlFlowTypes.js":
/*!************************************************************!*\
  !*** ./src/plugins/github/bin/generateGraphqlFlowTypes.js ***!
  \************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _generateGraphqlFlowTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../generateGraphqlFlowTypes */ \"./src/plugins/github/generateGraphqlFlowTypes.js\");\nprocess.stdout.write(Object(_generateGraphqlFlowTypes__WEBPACK_IMPORTED_MODULE_0__[\"default\"])());\n\n//# sourceURL=webpack:///./src/plugins/github/bin/generateGraphqlFlowTypes.js?");

/***/ }),

/***/ "./src/plugins/github/generateGraphqlFlowTypes.js":
/*!********************************************************!*\
  !*** ./src/plugins/github/generateGraphqlFlowTypes.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return generateGraphqlFlowTypes; });\n/* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prettier */ \"prettier\");\n/* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prettier__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _graphql_generateFlowTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../graphql/generateFlowTypes */ \"./src/graphql/generateFlowTypes.js\");\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema */ \"./src/plugins/github/schema.js\");\nfunction ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function generateGraphqlFlowTypes(){const prettierOptions=_objectSpread({parser:\"babel\"},prettier__WEBPACK_IMPORTED_MODULE_0___default.a.resolveConfig.sync(__filename));return Object(_graphql_generateFlowTypes__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Object(_schema__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(),prettierOptions);}\n\n//# sourceURL=webpack:///./src/plugins/github/generateGraphqlFlowTypes.js?");

/***/ }),

/***/ "./src/plugins/github/schema.js":
/*!**************************************!*\
  !*** ./src/plugins/github/schema.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return schema; });\n/* harmony import */ var _graphql_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../graphql/schema */ \"./src/graphql/schema.js\");\nfunction schema(){const s=_graphql_schema__WEBPACK_IMPORTED_MODULE_0__;const types={DateTime:s.scalar(\"string\"),GitObjectID:s.scalar(\"string\"),GitTimestamp:s.scalar(\"string\"),Int:s.scalar(\"number\"),String:s.scalar(\"string\"),URI:s.scalar(\"string\"),PullRequestReviewState:s.enum([\"PENDING\",\"COMMENTED\",\"APPROVED\",\"CHANGES_REQUESTED\",\"DISMISSED\"]),ReactionContent:s.enum([\"THUMBS_UP\",\"THUMBS_DOWN\",\"LAUGH\",\"HOORAY\",\"CONFUSED\",\"HEART\",\"ROCKET\",\"EYES\"]),Repository:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),name:s.primitive(s.nonNull(\"String\")),owner:s.node(\"RepositoryOwner\"),issues:s.connection(\"Issue\"),pullRequests:s.connection(\"PullRequest\"),defaultBranchRef:s.node(\"Ref\"),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),Issue:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),title:s.primitive(s.nonNull(\"String\")),body:s.primitive(s.nonNull(\"String\")),number:s.primitive(s.nonNull(\"Int\")),author:s.node(\"Actor\"),comments:s.connection(\"IssueComment\"),reactions:s.connection(\"Reaction\"),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),PullRequest:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),title:s.primitive(s.nonNull(\"String\")),body:s.primitive(s.nonNull(\"String\")),number:s.primitive(s.nonNull(\"Int\")),mergeCommit:s.node(\"Commit\"),additions:s.primitive(s.nonNull(\"Int\")),deletions:s.primitive(s.nonNull(\"Int\")),author:s.node(\"Actor\"),comments:s.connection(\"IssueComment\"),// yes, PRs have IssueComments\nreviews:s.connection(\"PullRequestReview\"),reactions:s.connection(\"Reaction\"),createdAt:s.primitive(s.nonNull(\"DateTime\")),baseRefName:s.primitive(s.nonNull(\"String\"))}),IssueComment:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),body:s.primitive(s.nonNull(\"String\")),author:s.node(\"Actor\"),reactions:s.connection(\"Reaction\"),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),PullRequestReview:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),body:s.primitive(s.nonNull(\"String\")),author:s.node(\"Actor\"),state:s.primitive(s.nonNull(\"PullRequestReviewState\")),comments:s.connection(\"PullRequestReviewComment\"),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),PullRequestReviewComment:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),body:s.primitive(s.nonNull(\"String\")),author:s.node(\"Actor\"),reactions:s.connection(\"Reaction\"),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),Reaction:s.object({id:s.id(),content:s.primitive(s.nonNull(\"ReactionContent\")),user:s.node(\"User\",s.unfaithful([\"User\",\"Organization\"])),createdAt:s.primitive(s.nonNull(\"DateTime\"))}),Ref:s.object({id:s.id(),// Unlike most node references, this is guaranteed non-null (but\n// we have no way to express that).\ntarget:s.node(\"GitObject\")}),GitObject:s.union([\"Blob\",\"Commit\",\"Tag\",\"Tree\"]),Blob:s.object({id:s.id(),oid:s.primitive(s.nonNull(\"GitObjectID\"))}),Commit:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),oid:s.primitive(s.nonNull(\"GitObjectID\")),message:s.primitive(s.nonNull(\"String\")),author:/* GitActor */s.nested({// The GitHub schema indicates that `date` can be null, but does\n// not indicate when this might be the case.\ndate:s.primitive(s.nullable(\"GitTimestamp\")),user:s.node(\"User\",s.unfaithful([\"User\",\"Bot\"]))}),parents:s.connection(\"Commit\"),// In contrast to the author.date, this is both nonNull and is\n// specifically the authoredDate. Docs for author.date suggest that\n// field might be the commiter date instead.\nauthoredDate:s.primitive(s.nonNull(\"GitTimestamp\"))}),Tag:s.object({id:s.id(),oid:s.primitive(s.nonNull(\"GitObjectID\"))}),Tree:s.object({id:s.id(),oid:s.primitive(s.nonNull(\"GitObjectID\"))}),Actor:s.union([\"User\",\"Bot\",\"Organization\"]),// actually an interface\nRepositoryOwner:s.union([\"User\",\"Organization\"]),// actually an interface\nUser:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),login:s.primitive(s.nonNull(\"String\"))}),Bot:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),login:s.primitive(s.nonNull(\"String\"))}),Organization:s.object({id:s.id(),url:s.primitive(s.nonNull(\"URI\")),login:s.primitive(s.nonNull(\"String\"))})};return s.schema(types);}\n\n//# sourceURL=webpack:///./src/plugins/github/schema.js?");

/***/ }),

/***/ "prettier":
/*!***************************!*\
  !*** external "prettier" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"prettier\");\n\n//# sourceURL=webpack:///external_%22prettier%22?");

/***/ })

/******/ });
});